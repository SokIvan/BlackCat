from fastapi import FastAPI, UploadFile, File, Form, BackgroundTasks, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import uvicorn
import logging
from typing import Optional
import os
from pathlib import Path
import asyncio

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="Computer Guard API")

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è –±–æ—Ç–∞
telegram_bot = None

async def set_webhook():
    """–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç webhook –¥–ª—è Telegram –±–æ—Ç–∞"""
    global telegram_bot
    try:
        # –ü–æ–ª—É—á–∞–µ–º URL –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        webhook_url = os.getenv('RENDER_EXTERNAL_URL')
        if not webhook_url:
            # –ï—Å–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º –±–∞–∑–æ–≤—ã–π URL Render
            render_app_name = os.getenv('RENDER_APP_NAME')
            if render_app_name:
                webhook_url = f"https://{render_app_name}.onrender.com"
            else:
                logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å URL –¥–ª—è webhook")
                return False
        
        webhook_path = f"{webhook_url}/webhook"
        logger.info(f"üîÑ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ webhook: {webhook_path}")
        
        if telegram_bot:
            # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π webhook –ø–µ—Ä–µ–¥ —É—Å—Ç–∞–Ω–æ–≤–∫–æ–π –Ω–æ–≤–æ–≥–æ
            await telegram_bot.bot.delete_webhook()
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ–≤—ã–π webhook
            await telegram_bot.bot.set_webhook(webhook_path)
            logger.info(f"‚úÖ Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {webhook_path}")
            return True
        else:
            logger.error("‚ùå –ë–æ—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ webhook")
            return False
            
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ webhook: {e}")
        return False

@app.on_event("startup")
async def startup_event():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    global telegram_bot
    
    try:
        from bot.telegram_bot import TelegramBot
        
        token = os.getenv('TELEGRAM_BOT_TOKEN')
        if not token:
            logger.error("‚ùå TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
            return
        
        telegram_bot = TelegramBot(token=token)
        logger.info("‚úÖ Telegram –±–æ—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ")
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º webhook –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
        webhook_success = await set_webhook()
        if webhook_success:
            logger.info("üöÄ Webhook —É—Å–ø–µ—à–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
        else:
            logger.warning("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å webhook, –±–æ—Ç –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –≤ —Ä–µ–∂–∏–º–µ polling")
        
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–æ—Ç–∞: {e}")

@app.post("/webhook")
async def handle_webhook(request: Request):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ webhook –æ—Ç Telegram"""
    global telegram_bot
    try:
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å–∞
        data = await request.json()
        logger.debug(f"üì® –ü–æ–ª—É—á–µ–Ω webhook –∑–∞–ø—Ä–æ—Å –æ—Ç Telegram")
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –±–æ—Ç–∞
        if telegram_bot:
            from aiogram.types import Update
            update = Update(**data)
            await telegram_bot.dp.feed_update(telegram_bot.bot, update)
            return JSONResponse(content={"status": "ok"})
        else:
            logger.error("‚ùå –ë–æ—Ç –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ webhook")
            return JSONResponse(content={"status": "error", "message": "Bot not available"}, status_code=503)
            
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ webhook: {e}")
        return JSONResponse(content={"status": "error", "message": str(e)}, status_code=500)

@app.get("/webhook")
async def get_webhook():
    """GET endpoint –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ webhook"""
    return {
        "status": "webhook_is_ready", 
        "message": "Webhook endpoint is working",
        "timestamp": __import__('datetime').datetime.now().isoformat()
    }

@app.get("/set-webhook")
async def manual_set_webhook():
    """–†—É—á–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ webhook (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)"""
    try:
        success = await set_webhook()
        if success:
            return {"status": "success", "message": "Webhook set manually"}
        else:
            return {"status": "error", "message": "Failed to set webhook"}
    except Exception as e:
        return {"status": "error", "message": str(e)}

@app.get("/delete-webhook")
async def delete_webhook():
    """–£–¥–∞–ª–µ–Ω–∏–µ webhook (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)"""
    global telegram_bot
    try:
        if telegram_bot:
            await telegram_bot.bot.delete_webhook()
            return {"status": "success", "message": "Webhook deleted"}
        else:
            return {"status": "error", "message": "Bot not available"}
    except Exception as e:
        return {"status": "error", "message": str(e)}

@app.get("/webhook-info")
async def webhook_info():
    """–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–µ–∫—É—â–µ–º webhook"""
    global telegram_bot
    try:
        if telegram_bot:
            webhook_info = await telegram_bot.bot.get_webhook_info()
            return {
                "status": "success",
                "webhook_info": {
                    "url": webhook_info.url,
                    "has_custom_certificate": webhook_info.has_custom_certificate,
                    "pending_update_count": webhook_info.pending_update_count,
                    "ip_address": webhook_info.ip_address,
                    "last_error_date": webhook_info.last_error_date,
                    "last_error_message": webhook_info.last_error_message,
                    "max_connections": webhook_info.max_connections,
                    "allowed_updates": webhook_info.allowed_updates
                }
            }
        else:
            return {"status": "error", "message": "Bot not available"}
    except Exception as e:
        return {"status": "error", "message": str(e)}

# ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ endpoint—ã –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ...

async def process_alert_background(
    computer_id: str,
    command: str,
    timestamp: str,
    detection_count: int,
    message: str,
    stranger_photo_path: Optional[str] = None,
    screenshot_path: Optional[str] = None
):
    """–§–æ–Ω–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"""
    global telegram_bot
    try:
        if telegram_bot:
            success = await telegram_bot.send_alert_to_user(
                computer_id=computer_id,
                message=message,
                detection_count=detection_count,
                timestamp=timestamp,
                stranger_photo_path=stranger_photo_path,
                screenshot_path=screenshot_path
            )
            if success:
                logger.info(f"‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –¥–ª—è –∫–æ–º–ø—å—é—Ç–µ—Ä–∞ {computer_id}")
            else:
                logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –∫–æ–º–ø—å—é—Ç–µ—Ä–∞ {computer_id}")
        else:
            logger.warning("‚ö†Ô∏è Telegram –±–æ—Ç –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω, —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ")
            
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ñ–æ–Ω–æ–≤–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}")
    finally:
        # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
        for file_path in [stranger_photo_path, screenshot_path]:
            if file_path and os.path.exists(file_path):
                try:
                    os.remove(file_path)
                    logger.debug(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª: {file_path}")
                except Exception as e:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞ {file_path}: {e}")

@app.post("/api/alert")
async def receive_alert(
    background_tasks: BackgroundTasks,
    computer_id: str = Form(...),
    command: str = Form(...),
    timestamp: str = Form(...),
    detection_count: int = Form(...),
    message: str = Form(...),
    stranger_photo: Optional[UploadFile] = File(None),
    screenshot: Optional[UploadFile] = File(None)
):
    """
    Endpoint –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ—Ç –∫–ª–∏–µ–Ω—Ç–æ–≤
    """
    try:
        logger.info(f"üì® –ü–æ–ª—É—á–µ–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç –∫–æ–º–ø—å—é—Ç–µ—Ä–∞ {computer_id}")
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª—ã –≤—Ä–µ–º–µ–Ω–Ω–æ
        saved_files = {}
        
        if stranger_photo:
            stranger_path = f"temp_stranger_{computer_id}.jpg"
            with open(stranger_path, "wb") as f:
                content = await stranger_photo.read()
                f.write(content)
            saved_files['stranger_photo'] = stranger_path
            logger.info(f"üì∏ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ —Ñ–æ—Ç–æ –Ω–µ–∑–Ω–∞–∫–æ–º—Ü–∞: {stranger_path}")
        
        if screenshot:
            screenshot_path = f"temp_screenshot_{computer_id}.png"
            with open(screenshot_path, "wb") as f:
                content = await screenshot.read()
                f.write(content)
            saved_files['screenshot'] = screenshot_path
            logger.info(f"üñ•Ô∏è –°–æ—Ö—Ä–∞–Ω–µ–Ω —Å–∫—Ä–∏–Ω—à–æ—Ç: {screenshot_path}")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –∑–∞–¥–∞—á—É –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        background_tasks.add_task(
            process_alert_background,
            computer_id=computer_id,
            command=command,
            timestamp=timestamp,
            detection_count=detection_count,
            message=message,
            stranger_photo_path=saved_files.get('stranger_photo'),
            screenshot_path=saved_files.get('screenshot')
        )
        
        return {
            "status": "success", 
            "message": "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø—Ä–∏–Ω—è—Ç–æ –≤ –æ–±—Ä–∞–±–æ—Ç–∫—É",
            "computer_id": computer_id
        }
            
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
        return {"status": "error", "message": str(e)}

@app.get("/")
async def root():
    global telegram_bot
    bot_status = "active" if telegram_bot else "inactive"
    
    # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ webhook
    webhook_status = "unknown"
    if telegram_bot:
        try:
            webhook_info = await telegram_bot.bot.get_webhook_info()
            webhook_status = "configured" if webhook_info.url else "not_configured"
        except:
            webhook_status = "error"
    
    return {
        "message": "Computer Guard API —Ä–∞–±–æ—Ç–∞–µ—Ç!",
        "version": "1.0",
        "status": "healthy",
        "telegram_bot": bot_status,
        "webhook": webhook_status,
        "endpoints": {
            "webhook": "POST /webhook",
            "webhook_info": "GET /webhook-info",
            "set_webhook": "GET /set-webhook",
            "delete_webhook": "GET /delete-webhook",
            "alert": "POST /api/alert",
            "health": "GET /health"
        }
    }

@app.get("/health")
async def health_check():
    global telegram_bot
    bot_alive = telegram_bot is not None
    return {
        "status": "healthy",
        "telegram_bot": "alive" if bot_alive else "inactive",
        "timestamp": __import__('datetime').datetime.now().isoformat()
    }

if __name__ == "__main__":
    uvicorn.run("app:app", host="0.0.0.0", port=8000, reload=True)